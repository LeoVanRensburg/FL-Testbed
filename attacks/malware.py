import os
import re
import sys
import numpy as np

# Constants
target_pattern = r"NODE_VALUES\s*=\s*{[^}]+}"

# Function to parse the NODE_VALUES dictionary
def parse_node_values(content):
    match = re.search(target_pattern, content)
    if match:
        # Execute the string to get the dictionary (be careful with this in production!)
        loc = {}
        exec(match.group(0), {'np': np}, loc)
        return loc['NODE_VALUES']
    return None

# Function to modify the values
def modify_values(values_dict, offset, nodes):
    new_dict = {}
    for key, value in values_dict.items():
        if key <= nodes:
            # Add offset to each value in the numpy array once
            new_dict[key] = np.array(value, dtype=float)  # Ensure it's a numpy array
            new_dict[key] = value + float(offset)  # Add offset just once
        else:
            new_dict[key] = value
    return new_dict

# Function to format the dictionary back to string
def format_node_values(values_dict):
    lines = ["NODE_VALUES = {"]
    for key in sorted(values_dict.keys()):
        # Convert numpy array to list for string representation
        values = values_dict[key]
        if isinstance(values, np.ndarray):
            array_values = values.tolist()
        else:
            array_values = values
        array_str = f"np.array({array_values})"
        lines.append(f"    {key}: {array_str},")
    lines.append("}")
    return "\n".join(lines)

# Function to restore original files
def restore_files(original_content):
    for path, content in original_content.items():
        with open(path, 'w') as f:
            f.write(content)

# Main function to find and modify files
def modify_files(offset, nodes):
    original_content = {}
    # Walk through the directories and get python files
    for root, dirs, files in os.walk("/home/whoami/Documents/DistributedConsensusAlgorithm/Algorithms"):
        for file in files:
            if file.endswith(".py"):
                full_path = os.path.join(root, file)
                # Read the file content
                with open(full_path, 'r') as f:
                    content = f.read()
                # If NODE_VALUES is found
                if "NODE_VALUES" in content:
                    # Store the original content to restore later
                    original_content[full_path] = content
                    # Modify the file
                    values_dict = parse_node_values(content)
                    if values_dict:
                        new_values = modify_values(values_dict, offset, nodes)
                        new_content = re.sub(target_pattern, format_node_values(new_values), content)
                        # Write the modified content back to the file
                        with open(full_path, 'w') as f:
                            f.write(new_content)
    return original_content

if __name__ == "__main__":
    # Check if the correct number of arguments are provided
    if len(sys.argv) != 3:
        print("Usage: python3 virus.py <offset> <nodes>")
        sys.exit(1)
    
    original_content = {}  # Define this outside try block so it's available in finally
    
    try:
        # Get command-line arguments for offset and number of nodes
        offset = int(sys.argv[1])
        nodes = int(sys.argv[2])
        
        # Modify the files and store original content
        original_content = modify_files(offset, nodes)
        
        # Wait for user input to reset
        input("Press Enter to reset the files to their original state...")
        
    except KeyboardInterrupt:
        print("\nScript interrupted by user. Resetting files...")
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("Attempting to reset files...")
    finally:
        # This will run even if the script crashes or is interrupted
        if original_content:
            restore_files(original_content)
            print("Files have been reset to their original state.")
